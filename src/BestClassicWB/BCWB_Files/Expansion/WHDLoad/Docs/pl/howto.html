<HTML>
<HEAD>
<TITLE>Programowanie WHDLoad</TITLE>
<meta name="DC.Language" content="pl">
<meta http-equiv="content-language" content="pl">
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2">
<!-- $Id: howto.html 1.6 2014/12/04 23:37:38 wepl Exp wepl $ -->
</HEAD>
<BODY>
<h3>Schemat dzia³ania programu</h3>
<p>Poni¿sza tabela pokazuje kolejno¶æ wykonywanych operacji, które nastêpuj±
po uruchomieniu programy zainstalowanego przy pomocy pakietu WHDLoad.
Mam nadziejê, ¿e to pomo¿e zrozumieæ jak dzia³a WHDLoad i jak WHDLoad,
plik .slave oraz zainstalowany program wspó³pracuj±.</p>
<table cellpadding=3>
  <tr>
    <td valign=top>U¿ytkownik</td>
    <td>
      <ul>
        <li>uruchamia demo lub grê poprzez klikniêcie na ikonê lub poprzez uruchomienie WHDLoad z linii poleceñ (CLI)
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>System operacyjny</td>
    <td valign=top>
      <ul>
        <li>uruchamia plik wykonywalny WHDLoad
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>WHDLoad</td>
    <td>
      <ul>
        <li>sprawdza ¶rodowisko sprzêtowe i programowe
        <li>wczytuje i sprawdza plik .slave
        <li>alokuje wymagan± dla zainstalowanego programu ilo¶æ pamiêci
        <li>je¶li <a href="opt.html#Preload">Preload/S</a> jest w³±czone, wczytuje
            obrazy dysków i plików do RAM-u (tylko wtedy, gdy dostêpna jest wolna
            pamiêæ)
        <li>wy³±cza System Operacyjny (wy³±cza multitasking i przerwania, degraduje
            ko¶ci graficzne do stanu OCS, initializuje ca³y sprzêt zgodnie ze zdefiniowanymi warto¶ciami)
        <li>wykonuje skok do pliku .slave
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Slave</td>
    <td>
      <ul>
        <li>wczytuje g³ówny plik wykonywalny zainstalowanego programu poprzez wywo³anie funkcji
            WHDLoad (np. <a
            href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a> lub <a
            href="../autodoc.html#resload_LoadFile">resload_LoadFile</a>)
        <li>&quot;³ata&quot; g³ówny plik wykonywalny (tak, aby program wczyta³ swoje dane poprzez
            plik .slave, naprawi³ problemy zwi±zane z kompatybilno¶ci±, uaktywni³ opcjê
            wyj¶cia z programu)
        <li>uruchamia g³ówny plik wykonywalny
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Zainstalowany program</td>
    <td>
      <ul>
        <li>robi swoje
        <li>podczas odczytu danych z dysku, odwo³uje siê do pliku .slave (gdy¿ plik .slave
            wcze¶niej na³o¿y³ siê na niego, &quot;³ataj±c&quot; go), a nastêpnie plik .slave
            odwo³uje siê do WHDLoad, który czê¶ciowo w³±cza OS, aby wczyta³ dane
            (tylko je¶li dane nie s± <a
            href="opt.html#Preload">za³adowywane wcze¶niej (Preload)</a>); na koniec wraca do
            dalszego wykonywania zainstalowanego programu.
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>U¿ytkownik</td>
    <td>
      <ul>
        <li>wychodzi z programu poprzez naci¶niêcie zdefiniowanego klawisza wyj¶cia (<a
            href="opt.html#QuitKey">QuitKey</a>)
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>Slave</td>
    <td>
      <ul>
        <li>wywo³uje WHDLoad poprzez funkcjê <a
            href="../autodoc.html#resload_Abort">resload_Abort</a>
      </ul>
    </td>
  </tr>
  <tr>
    <td valign=top>WHDLoad</td>
    <td>
      <ul>
        <li>ponownie w³±cza OS (rejestry sprzêtowe, ekran oraz pamiêæ wracaj± do poprzedniego stanu),
        <li>uwalnia wszystkie zaalokowane obszary i zasoby,
        <li>wraca do systemu.
      </ul>
    </td>
  </tr>
</table>
<h3>Jak zainstalowaæ prosty, jednodyskowy program wczytywany po ¶cie¿kach</h3>
To jest bardzo ma³y i krótki poradnik jak stworzyæ wersjê instalacyjn± niesystemowej gry/dema
wykorzystuj±c± WHDLoad. Poradnik opisuje zwyk³±, idealn±, prost± sytuacjê.
W rzeczywisto¶ci taka sytuacja prawdopodobnie nigdy nie wyst±pi. W ramach
zapoznania siê ze specjalnymi przypadkami i problemami, przeczytaj kolejny
rozdzia³.
<ol>
  <li>Pocz±tki
    <ul>
      <li>Stwórz katalog, w których przechowywane s± wszystkie pliki.
      <li>Stwórz obraz dysku u¿ywaj±c programu <A HREF="dic.html"> DIC </A>.
      <li>Stwórz plik <a href="opt.html#optwb">#?.info</a> z &quot;WHDLoad&quot;
          jako &lt;Default Tool&gt; oraz Tooltype &quot;SLAVE=#?&quot; zawieraj±cym
          nazwê pliku .slave. (lub pro¶ciej, skopiuj ikonê z Przyk³adowej
          Instalacji i wy³±cz wszystkie parametry za wyj±tkiem &quot;SLAVE=&quot;).
    </ul>
  <li>Plik .slave<br>
    Aby stworzyæ plik .slave potrzebujemy nastêpuj±cych informacji:
    <ol>
      <li>gdzie na dysku znajduje siê g³ówny plik wykonywalny (loader)?
      <li>gdzie wewn±trz pliku wykonywalnego znajduje siê disk loader?
    </ol>
    Aby zdobyæ te informacje, najpierw nale¿y przeanalizowaæ botblok.
    W wiêkszo¶ci przypadków, g³ówny plik wykonywalny bêdzie wczytywany w³a¶nie
    st±d przy pomocy exec.DoIO(). Czasami bootblock zawiera specjalny trackloader.
    Kolejn± czynno¶ci± jest utworzenie pliku .slave, który zastêpuje botblok
    i wczytuje g³ówny plik wykonywalny z obrazu dysku. Teraz nale¿y wyci±gn±æ
    g³ówny plik wykonywalny z obrazu dysku lub ze <a
    href="dump.html#memory">zrzutu pamiêci</a>. Nastêpnie musimy odnale¼æ
    w nim loader. Najszybsz± metod± jest odszukanie ci±gu
    <tt>$AAAAAAAA</tt> (u¿ywanego przez MFM decoding) przy pomocy hex-edytora.
    Nastêpnie wycinamy obszar o d³ugo¶ci
    (+/- <tt>$1000</tt> bajtów), deasemblujemy go i odszukujemy pocz±tek
    procedury. Rozszyfrowujemy listê parametrów i tworzymy kod pliku .slave,
    który zast±pi procedurê loadera, w taki sposób, ¿e wszystkie odwo³ania do
    loadera bêd± przekierowane do pliku .slave. Nastêpnie plik .slave
    dostosuje parametry i wywo³a z WHDLoad funkcjê
    <a
    href="../autodoc.html#resload_DiskLoad">resload_DiskLoad</a>.
  <li>W idealnej sytuacji wersja instalacyjna jest gotowa.<br>
Jedyn± rzecz±, która pozosta³a do zrobienia jest stworzenie ³adnej Ikony.
Wyci±gnij z programu dwa obrazki wykorzystuj±c do tego <a href="snoop.html">opcjê snoop</a> w WHDLoad i program <a href="sp.html">SP</a> lub jakiego¶ programu zatrzymuj±cego dzia³anie innych programów albo UAE.
Nastêpnie stwórz ikonê. Zalecana jest 16-kolorowa paleta <a href="http://aminet.net/package/pix/mwb/RomIcons10.lha">RomIcon</a>.
</ol>
<h3>Mo¿liwe problemy i sytuacje wyj±tkowe</h3>
<h4>Niestandardowy trackloader</h4>
Niektóre programy u¿ywaj± swoich w³asnych formatów. Oznacza to, ¿e <a
href="dic.html">DIC</a> nie mo¿e stworzyæ obrazów dysków. Aby je stworzyæ
nale¿y do tego celu u¿yæ programu <a href="rawdic.html">RawDIC</a>.
Aby zasiêgn±æ wiêcej informacji, przeczytaj dokumentacjê programu RawDIC.
<h4>Zmiana dysków</h4>
Je¿eli program wykorzystuje wiêcej ni¿ jeden dysk, plik .slave musi przekierowaæ
dostêpy do dysków do odpowiedniego obrazu dysku. Czasami nie jest to proste.
Niektóre programy obs³uguj± wiêcej ni¿ jedn± stacjê dysków, tak wiêc mo¿na
wykorzystaæ numer tego urz±dzenia w celu wyboru dysku. Wiêkszo¶æ programów
u¿ywa specjalnego identyfikatora na ka¿dym dysku w celu ich rozró¿nienia.
W takim przypadku nale¿y wykorzystaæ zmienn±, która przechowuje numer dysku
i przy ka¿dej próbie dostêpu do identyfikatora dysku zwiêkszaæ jej warto¶æ (je¿eli
dojdziemy do ostatniego dysku, nale¿y j± zmniejszaæ). Loader odczytuje identyfikator
dysku w kó³ko, do czasu gdy prawid³owy dysk zostanie w³o¿ony. Czasami pojawiaj±
siê komunikaty z pro¶b± o w³o¿enie dysku, które nale¿y deaktywowaæ.
<h4>Zapisywanie tablic z najlepszymi wynikami</h4>
Nie ma tutaj zbyt wiele do powiedzienia. Wykorzystaj <a
href="../autodoc.html#resload_SaveFile">resload_SaveFile</a>, aby zapisaæ odpowiedni
obszar pamiêci na dysk. Je¿eli chcesz, mo¿esz go trochê zaszyfrowaæ, aby lamerzy
za szybko nie doszli do tego, jak oszukiwaæ. Nie jest zalecane dokonywanie zapisów
bezpo¶rednio do obrazów dysków (wykorzystuj±c
<a href="../autodoc.html#resload_SaveFileOffset">resload_SaveFileOffset</a>), poniewa¿, w sytuacji
jakiego¶ b³êdu (np. zawieszenie), istnieje du¿e prawdopodobieñstwo, ¿e obrazy
dysków zostan± uszkodzone.
<h4>Zapisy stanów gry - Savegames</h4>
Sposób dokonywania zapisów stanu gry odbywa siê w ten sam sposób co zapis tablic z najlepszymi wynikami.
<h4>Dostêp do systemu operacyjnego</h4>
W czasie, gdy plik .slave i zainstalowany program s± wykonywane, nie
jest mo¿liwy dostêp do systemu operacyjnego! W zwi±zku
z tym ka¿da próba dostêpu do systemu, jaka mo¿e siê odbyæ przez zainstalowany
program, musi zostaæ wy³±czona. Je¿eli nie jest ich du¿o i dla ¶rodowiska
WHDLoad s± ma³o istotne (jak np.
exec.Disable() lub exec.SuperState()) mo¿na je zdeaktywowaæ instrukcj± NOP (<tt>$4e71</tt>).
Je¿eli dostêpy do systemu s± wa¿nymi elementami pracy zainstalowanego programu
(jak np. exec.DoIO()), nale¿y je przekierowaæ do pliku .slave i zaemulowaæ.
Je¿eli jest ich du¿o, w nieu¿ywanym obszarze pamiêci nale¿y stworzyæ
prost± exec.library (inicjonowan± przez d³ugie s³owo w adresie <tt>$4</tt>). Za przyk³ad
niech pos³u¿y do³±czone ¼ród³o Oscar.slave, które emuluje
exec.AllocMem(). Aby wykryæ dostêp do systemu operacyjnego, nale¿y pos³u¿yæ siê
pocz±tkow± tablic± execbase, która jest wstawiana do adresu
<tt>$f0000001</tt>, aby sprawiæ, ¿e wszystkie procedury, które wykorzystuj±
execbase wywo³aj± wyj±tek &quot;Address Error&quot;.<br>
Je¿eli wywo³añ funkcji systemowych jest bardzo du¿o, nale¿y wykorzystaæ
jeden z pakietów kickemu, który znajduje siê w pakiecie WHDLoad dla developerów.
Znajduje siê tam jeden pakiet dla Kickstartu 1.3
('src/sources/whdload/kick13.s') i jeden dla Kickstartu 3.1 ('src/sources/whdload/kick31.s').
Pakiety wymagaj± oryginalnych obrazów kickstartów i utworz± one kompletne
¶rodowisko systemowe wewn±trz WHDLoad. Wiêcej informacji dostêpnych jest
w specjalnych dokumentacjach.
<h3>Problemy z kompatybilno¶ci±</h3>
<h4>Ograniczony dostêp do adresów wolnej pamiêci na procesorach 68000/68010/68ec020</h4>
Na tych procesorach przestrzeñ adresowa jest ograniczona do 16 MB
(<tt>$000000...$ffffff</tt>), poniewa¿ procesor posiada tylko 24 linie adresowe.
W wyniku tego wszystkie próby dostêpu do wy¿szych adresów wykonywane s± na
ni¿szych 16 MB poprzez ignoracjê najmniej znacz±cych 8 bitów. Niektóre
programy u¿ywaj± tych bitów do przechowywania danych lub po prostu zapominaj±
ich wyczy¶ciæ. Na procesorach takich, jak
68020/680ec30/68030/68040/68060, które posiadaj± z pe³n±, 4-GB przestrzeni± adresow±,
co¶ takiego po prostu nie zadzia³a z powodu dostêpu do pe³nych, 32-bitowych adresów.<br>
Aby rozwi±zaæ ten problem, trzeba &quot;za³ataæ&quot; dostêpy do tych adresów poprzez
przekierowanie ich do w³a¶ciwych adresów.<br>
Czasami powodem dostêpu do dziwnych adresów mo¿e byæ nieinicjowanie wska¼nika.
W takim przypadku pomaga wyczyszczenie <tt>$400</tt> - <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a>.
<h4>Ro¿ne ramki stosu dla ró¿nych procesorów</h4>
Ramki stosu tworzone przez procesor na przerwaniach i wyj±tkach
s± ró¿ne dla ró¿nych cz³onków rodziny 68k. Na 68000 ramka stosu wynosi 6 bajtów,
za wyj±tkiem b³êdów szyny i adresów (Bus Errors i Address Errors). Ramka stosu
zawiera zapisane SR w rejestrze (a7) i zapisane PC w rejestrze (2,a7). Na wszystkich
procesorach od 68010 wzwy¿, minimalna ramka stosu wynosi 8 bajtów oraz dodatkowo
zawiera liczbê wektorow± jako s³owo w rejestrze (6, a7). Ta ¾quot;z³o¿ona z
czterech s³ów&quot; ramka stosu formatowana jest na stan <tt>$0</tt> i tworzona jest dla potrzeb polecenia &quot;Trap #xx&quot;
oraz przerwañ (Interrupts) na procesorach 68010-68060. Ramki stosu dla innych wyj±tków
s± ró¿ne dla ró¿nych procesorów. Instrukcja RTE dzia³a inaczej ni¿
na 68000. Na 68000 po prostu przywraca poprzednie warto¶ci rejestrów SR i PC i dalej
kontynuuje pracê programu od przerwanego adresu. Na 68010 (i wy¿szych) dodatkowo
zostanie zwolniona ramka stosu w zale¿no¶ci od jej sformatowania.<br>
Niektóre adresy wyrzucaj± adres (PC) oraz SR i dopiero wtedy wykonuj± instrukcjê RTE.
Tak dzieje siê tylko na 68000. Takie dzia³anie na procesorach od 68010 wzwy¿
powoduje nieoczekiwane wyniki.
<br>Je¿eli program tak robi, nale¿y to poprawiæ. Czasami wystarcza zamiana
instrukcji RTE na RTR.
<h4>MOVEM.x RL,-(An) n a 68000/010 i 68020-68060</h4>
Istnieje ró¿nica, je¿eli rejestr u¿ywany w trybie wcze¶niejszego zmniejszania zawarto¶ci (RL)
jest równie¿ zawarty w spisie rejestrów. Dla 68020-68060 warto¶æ zapisywana
do pamiêci jest bazow± warto¶ci± rejestru pomniejszon± o rozmiar operacji.
Procesory 68000 i 68010 zapisuj± bazow± warto¶æ rejestru (nie pomniejszon±). <br>Poniewa¿ taka
konstrukcja nie jest za bardzo u¿yteczna, nie jest znany ¿aden z obecnych programów, który wykazywa³by w zwi±zku z tym jakie¶ problemy.
<h3>Ogólne zasady pisania w³asnych programów instalacyjnych</h3>
<ul>
<li>Nie zmieniaj rejestrów procesora obecnych w wy¿szych procesorach takich jak VBR czy CACR. VBR zawsze wynosi 0 z programistycznego punktu widzenia, nawet je¿eli zosta³ przesuniêty z powodu emulacji Auto Vectorów (i poleceñ &quot;Trap&quot;, je¿eli flaga <a
href="../autodoc.html#WHDL_EmulTrap">WHDL_EmulTrap</a> jest ustawiona).
Bity w CACR s± ró¿ne dla ka¿dego procesora. Istnieje tylko jedna metoda zmiany
<a href="cache.html">buforów</a>, przy pomocy <a href="../autodoc.html">resload_SetCACR/SetCPU</a> i bitdef z 'exec/execbase.i' i 'whdload.i'.
Ca³a czê¶æ kodu instalowanego programu, która narusza te rejestry musi byæ
wy³±czona lub ominiêta. W przeciwnym razie WHDLoad nie bêdzie dzia³aæ poprawnie!
<li>Nigdy nie modyfikuj obrazów dysków. Ma to ogromn± zaletê, w chwili, gdy ktokolwiek chce uruchomiæ grê z dyskietek. Wystarczy tylko zapisaæ obrazy z powrotem na dyskietki (zak³adaj±c, ¿e program dzia³a bez stosowania poprawek).
<li>Nigdy nie stosuj oryginalnego kodu programu bezpo¶rednio w pliku .slave (problem praw autorskich).
<li>W³±czaj Cache tylko wtedy, gdy jeste¶ pewien, ¿e bêdzie to dzia³aæ na wszystkich procesorach.
<li>Wykorzystuj najmniejsz± mo¿liw± ilo¶æ pamiêci dla <a href="../autodoc.html#ws_BaseMemSize">ws_BaseMemSize</a>. Niektórzy lubi± umieszczaæ tagi na koñcu pamiêci Chip, tak wiêc pomaga wykorzystywanie tylko adresów <tt>$1f0000</tt> zamiast <tt>$200000</tt>.
</ul>
<h3>Sztuczki i kruczki</h3>
<h4>Co lepiej wykorzystywaæ: obrazy dysków, czy pliki?</h4>
Czasami bêdzie istnia³a mo¿liwo¶æ u¿ycia obrazów dysków lub plików znajduj±cych
siê na dysku. Obie metody maj± swoje zalety. Do utworzenia pliku .slave, wykorzystanie obrazów dysków
jest z regu³y prostsze i szybsze. Z kolei bezpo¶rednie pliki programu s±
prostsze do buforowania (w przypadku, gdy jest niewiele dostêpnej pamiêci
lub pamiêæ jest pofragmentowana). Wymagana ilo¶æ wolnego miejsca na twardym
dysku czasami równie¿ bêdzie w tym przypadku mniejsza. Obrazy dysków powinny
byæ stosowane tylko wtedy, je¿eli liczba plików przekracza liczbê 30.
</BODY>
</HTML>
